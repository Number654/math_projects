            for x in range(given.nvars):  # checking every variant of column locations for one of variables
                if self.contains(given):
                    _res = ""
                    for v in head:
                        _res += v
                    if _res not in result:
                        result.append(_res)
                        # print(_res, x)

                if vector_left:  # Для движения налево
                    if

                if x+1 == given.nvars:  # If we gonna move column of values of function
                    break
                if head not in moved_variants:
                    moved_variants.append(head)

                given.move_column(x, x+1)
                head = move(head, x, x+1)





"""
        Мы должны двигать столбцы для каждой из переменных, так, чтобы каждый столбец каждой переменной
        побывал на каждой позиции, таким образом мы добъемся перебора всех вариаций переданного в
        этот метод фрагмента таблицы истинности.

        Для осуществления этой задачи необходимо пройтись циклом по всем переменным. В теле этого цикла
        необходимо рассмотреть три случая:
          1. когда столбец переменной находится на левом краю таблицы (т. е. его нельзя двигать левее);
          2. когда столбец переменной находится на правом краю таблицы (не считая столбец значений
             функции, разумеется) (т. е. его нельзя двигать правее);
          3. когда столбец находится на позиции между левым и правым краем.

        В первом случае создается цикл внутри главного (см. начало), который проходится по всем переменным
        еще раз (в порядке возрастания индексов названий переменных). Таким образом будет реализовано
        движение столбца только направо (что, собственно, и требуется).

        Во втором случае тоже создается цикл внутри главного, который тоже (см. случай 1) проходится по
        всем переменным еще раз, но теперь в порядке убывания индексов названий переменных. Таким образом
        будет реализовано движение столбца только налево.

        В третьем случае необходимо поступить следующим образом. Сначала необходимо создать цикл
        внутри главного (аналогично двум другим случаям), который будет двигать столбец направо до тех
        пор, пока он не "упрется" в правый край данного фрагмента таблицы истинности. После этого цикл
        завершается. Тогда начинается следующий цикл, который будет двигать столбец налево до тех пор,
        пока он не "упрется" в левый край данного фрагмента таблицы истинности. При этом следует начинать
        движение влево относительно начального положения столбца, рассматриваемого на момент текущей
        итерации главного цикла, так как в противном случае цикл, двигающий влево повторно переберет
        комбинцаии, полученные в цикле для движения направо.

        Во всех трех случаях, что очевидно, необходимо реализовать проверку на совпадения комбинации
        с полной ("большой") таблицей истинности. При этом, не нужно останавливать циклы при первом
        совпадении, так как решений поставленной задачи может быть несколько. Также важно проверять
        комбинации на повторы, которые неизбежно будут возникать при использовании описываемого
        алгоритма в связи с зависимостью положения остальных столбцов от положения столбца, подвергаемого
        перемещению (другие столбцы будут смещаться, как бы освобождая место для перемещения в него).
        Такую проверку лучше реализвать, сперва подвергая перемещению шапку фрагмента таблицы
        истинности и записывая новые варианты таких измененных шапок. Таким образом мы избежим лишней
        нагрузки на процессор и оперативную память, ведь пермещение всего столбца требует многократного
        перемещения значений в каждом из рядов.

        Важно вспомнить, что решениями задач такого типа является найденные шапки фрагмента таблицы
        истингости, следовательно, эти шапки также должны сохранятья в список решений. В последний
        они будут добавляться по мере назождения решений, что очевидно. Добавление в список решений
        конкретной шапки происхоит в том случае, если рассматриваемая комбинация фрагмента таблицы
        истинности совпадает с полной ("большой") таблицей истинности.

        Примечание. Выражение "совпадает с полной таблицей истинности" следует понимать как факт того,
        что та или иная комбинация фрагмента таблицы истинности содержится в полной таблице истинности.

        Примечание 2. Решением поставленной задачи может являться и шапка, соответствующая
        неизмененному (исходному) фрагменту таблицы истинности. Из этого следует, что во всех циклах,
        осуществляющих изменения, сперва необходимо рассматривать вариант фрагмента таблицы истинности
        с прошлой итерации (либо до главного цикла, что есть одно и то же) и только после этого и после
        проверки вышеуказанного варианта на соответствие ... (см. выше) ... необходимо подвергать его
        изменениям.
        """



            if not moving_var:  # Для первой переменной по списку, так как ее нельзя двигать налево
                self.__moving_cycle(given, head, result, moved_variants, 0)
            elif moving_var+1 == vars_amount:  # Для последней переменной, так как ее нельзя двигать направо
                self.__moving_cycle(given, head, result, moved_variants, moving_var, right=False)
            else:  # Для переменной, находящейся между левым и првавым краем
                # Сначала двигаем направо
                self.__moving_cycle(given, head, result, moved_variants, moving_var)
                given, head = copy(given_const), copy(head_const)  # Откат, чтобы теперь двигать налево
                self.__moving_cycle(given, head, result, moved_variants, moving_var, right=False)

            given, head = copy(given_const), copy(head_const)  # Откат, чтобы следущий столбец прошел весь путь







print(self.vars[moving_var])
            if not moving_var:  # Для первой переменной по списку, так как ее нельзя двигать налево
                for x in range(vars_amount):
                    if self.contains(given):
                        j = ''.join(head)
                        if j in result:
                            continue
                        result.append(j)
                    if x + 1 == vars_amount:
                        break
                    print(self.vars[moving_var], x, x+1)
                    given.move_column(x, x + 1)
                    delta_head = move(head, x, x+1)
                    if delta_head in moved_variants:
                        continue
                    head = copy(delta_head)
                    moved_variants.append(head)
            elif moving_var+1 == vars_amount:  # Для последней переменной, так как ее нельзя двигать направо
                for x in range(moving_var, -1, -1):
                    if head in moved_variants:
                        continue
                    if self.contains(given):
                        j = ''.join(head)
                        if j in result:
                            continue
                        result.append(j)
                    if not x:
                        break
                    print(self.vars[moving_var], x, x-1)
                    given.move_column(x, x - 1)
                    delta_head = move(head, x, x-1)
                    if delta_head in moved_variants:
                        continue
                    head = copy(delta_head)
                    moved_variants.append(head)
            else:  # Для переменной, находящейся между левым и првавым краем
                # Сначала двигаем направо
                for x in range(moving_var, vars_amount):
                    if head in moved_variants:
                        continue
                    if self.contains(given):
                        j = ''.join(head)
                        if j in result:
                            continue
                        result.append(j)
                    if x + 1 == vars_amount:
                        break
                    print(self.vars[moving_var], x, x+1)
                    given.move_column(x, x + 1)
                    delta_head = move(head, x, x+1)
                    if delta_head in moved_variants:
                        continue
                    head = copy(delta_head)
                    moved_variants.append(head)
                given, head = copy(given_const), copy(head_const)  # Откат, чтобы теперь двигать налево
                for x in range(moving_var, -1, -1):
                    if head in moved_variants:
                        continue
                    if self.contains(given):
                        j = ''.join(head)
                        if j in result:
                            continue
                        result.append(j)
                    if not x:
                        break
                    print(self.vars[moving_var], x, x-1)
                    given.move_column(x, x - 1)
                    delta_head = move(head, x, x-1)
                    if delta_head in moved_variants:
                        continue
                    head = copy(delta_head)
                    moved_variants.append(head)

            given, head = copy(given_const), copy(head_const)  # Откат, чтобы следущий столбец прошел весь путь



